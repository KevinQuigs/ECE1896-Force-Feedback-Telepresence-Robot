#!/usr/bin/env python3
"""
WebSocket Bridge Server for Telepresence Robot
Bridges between browser (WebSocket) and ESP32 (Serial)
"""

import asyncio
import websockets
import json
import serial
import struct
from datetime import datetime

# Configuration
WEBSOCKET_PORT = 8080
SERIAL_PORT = '/dev/ttyUSB0'  # Change to your ESP32 port (might be /dev/ttyACM0)
SERIAL_BAUD = 115200

# Communication mode: 'serial' or 'udp'
COMM_MODE = 'serial'
ESP32_UDP_IP = '192.168.1.50'  # If using UDP
ESP32_UDP_PORT = 5000

class RobotBridge:
    def __init__(self):
        self.clients = set()
        self.serial_conn = None
        self.udp_socket = None
        
        if COMM_MODE == 'serial':
            self.setup_serial()
        elif COMM_MODE == 'udp':
            self.setup_udp()
    
    def setup_serial(self):
        """Initialize serial connection to ESP32"""
        try:
            self.serial_conn = serial.Serial(
                SERIAL_PORT, 
                SERIAL_BAUD, 
                timeout=0.01
            )
            print(f"Serial connected: {SERIAL_PORT} @ {SERIAL_BAUD} baud")
        except Exception as e:
            print(f"Serial connection failed: {e}")
            print("Check: ls /dev/ttyUSB* or ls /dev/ttyACM*")
    
    def setup_udp(self):
        """Initialize UDP socket for ESP32"""
        import socket
        self.udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        print(f"UDP configured: {ESP32_UDP_IP}:{ESP32_UDP_PORT}")
    
    async def register_client(self, websocket):
        """Register new WebSocket client"""
        self.clients.add(websocket)
        print(f"Client connected. Total clients: {len(self.clients)}")
    
    async def unregister_client(self, websocket):
        """Unregister WebSocket client"""
        self.clients.discard(websocket)
        print(f"Client disconnected. Total clients: {len(self.clients)}")
    
    async def handle_client_message(self, message):
        """
        Handle incoming message from browser (VR controller/headset and finger tracking data)
        Format: {type: 'tracking', rotationFinger : {t, i, m, r, p}, positionHand: {x, y, z}, rotationHand: {p, y, r}, rotationHead: {p, y, r}}
        """
        try:
            data = json.loads(message)
            msg_type = data.get('type', 'unknown')
            
            if msg_type == 'tracking':
                # Extract position and rotation
                rot_finger = data.get('rotationFinger', {})
                pos_hand = data.get('positionHand', {})
                rot_hand = data.get('rotationHand', {})
                rot_head = data.get('rotationHead', {})

                
                # Pack data for ESP32 (binary format)
                # Format: [message_type(1 byte)][THUMB(4)][INDEX(4)][MIDDLE(4)][RING(4)][PINKY(4)][Hand_pitch(4)][Hand_yaw(4)][Hand_roll(4)][Hand_x(4)][Hand_y(4)][Hand_z(4)][Head_pitch(4)][Head_yaw(4)][Head_roll(4)]
                packed = struct.pack(
                    '<Bfffffffffffff',  # < = little-endian, B = unsigned char, f = float
                    0x01,  # Message type: tracking data
                    #fingers
                    rot_finger.get('t', 0.0), #thumb
                    rot_finger.get('i', 0.0), #index
                    rot_finger.get('m', 0.0), #middle
                    rot_finger.get('r', 0.0), #ring
                    rot_finger.get('p', 0.0), #pinky
                    #hand
                    pos_hand.get('x', 0.0), 
                    pos_hand.get('y', 0.0), 
                    pos_hand.get('z', 0.0), 
                    rot_hand.get('p', 0.0), 
                    rot_hand.get('y', 0.0),   
                    rot_hand.get('r', 0.0), 
                    #head
                    rot_head.get('p', 0.0), 
                    rot_head.get('y', 0.0),
                    rot_head.get('r', 0.0) 
                )
                
                await self.send_to_esp32(packed)
                
            elif msg_type == 'command':
                # Handle discrete commands (grip, release, etc.)
                command = data.get('command', '')
                await self.send_to_esp32(f"CMD:{command}\n".encode())
                
            elif msg_type == 'ping':
                # Health check
                return {'type': 'pong', 'timestamp': datetime.now().isoformat()}
                
        except json.JSONDecodeError:
            print(f"ERR: Invalid JSON: {message}")
        except Exception as e:
            print(f"ERR: Error handling message: {e}")
        
        return None
    
    async def send_to_esp32(self, data):
        """Send data to ESP32 via serial or UDP"""
        try:
            if COMM_MODE == 'serial' and self.serial_conn:
                self.serial_conn.write(data)
            elif COMM_MODE == 'udp' and self.udp_socket:
                self.udp_socket.sendto(data, (ESP32_UDP_IP, ESP32_UDP_PORT))
        except Exception as e:
            print(f"Error sending to ESP32: {e}")
    
    async def read_from_esp32(self):
        """Read sensor data from ESP32 and broadcast to all clients"""
        print("[ESP32 Reader] Starting ESP32 reader task")
        while True:
            try:
                if COMM_MODE == 'serial' and self.serial_conn:
                    if self.serial_conn.in_waiting > 0:
                        # Read line from ESP32
                        line = self.serial_conn.readline().decode('utf-8', errors='ignore').strip()
                        
                        if line:
                            print(f"ESP32 -> Pi: {line}")  # Debug output
                            
                            # Parse sensor data from ESP32
                            sensor_data = self.parse_esp32_data(line)
                            
                            if sensor_data and self.clients:
                                # Broadcast to all connected clients
                                message = json.dumps(sensor_data)
                                print(f"Pi -> Browser ({len(self.clients)} clients): {message}")  # Debug output
                                
                                # Send to each client individually with error handling
                                for client in list(self.clients):  # Use list() to avoid set changed during iteration
                                    try:
                                        await client.send(message)
                                    except Exception as e:
                                        print(f"[ESP32 Reader] Error sending to client: {e}")
                                        # Don't remove client here, let handle_websocket do it
                
                await asyncio.sleep(0.01)  # 100Hz polling rate
                
            except serial.SerialException as e:
                print(f"[ESP32 Reader] Serial error: {e}")
                await asyncio.sleep(1.0)  # Wait longer on serial errors
            except Exception as e:
                print(f"[ESP32 Reader] Error reading from ESP32: {e}")
                import traceback
                traceback.print_exc()
                await asyncio.sleep(0.1)
    
    def parse_esp32_data(self, line):
        """
        Parse sensor data from ESP32
        
        Supported formats:
        1. Simple analog test: "ANALOG:1234"
        2. Full force sensors: "FORCE:12.5,34.6,56.7,78.9,90.1"
        3. Legacy format: "FORCE:12.5,TEMP:25.3"
        """
        try:
            data = {'type': 'sensor', 'timestamp': datetime.now().isoformat()}
            
            # Simple analog value test
            if line.startswith('ANALOG:'):
                value_str = line.replace('ANALOG:', '').strip()
                analog_value = float(value_str)
                data['analog'] = analog_value
                print(f"Parsed analog value: {analog_value}")
                return data
            
            # Full force sensor data (comma-separated values after FORCE:)
            elif line.startswith('FORCE:'):
                values_str = line.replace('FORCE:', '').strip()
                values = values_str.split(',')
                
                if len(values) >= 5:
                    data['thumb'] = float(values[0])
                    data['index'] = float(values[1])
                    data['middle'] = float(values[2])
                    data['ring'] = float(values[3])
                    data['pinky'] = float(values[4])
                    print(f"Parsed force sensors: T={data['thumb']}, I={data['index']}, M={data['middle']}, R={data['ring']}, P={data['pinky']}")
                    return data
            
            # Legacy format (multiple key:value pairs)
            elif ':' in line:
                parts = line.split(',')
                for part in parts:
                    if ':' in part:
                        key, value = part.split(':', 1)
                        
                        if key == 'THUMB':
                            data['thumb'] = float(value)
                        elif key == 'INDEX':
                            data['index'] = float(value)
                        elif key == 'MIDDLE':
                            data['middle'] = float(value)
                        elif key == 'RING':
                            data['ring'] = float(value)
                        elif key == 'PINKY':
                            data['pinky'] = float(value)
                        elif key == 'TEMP':
                            data['temperature'] = float(value)
                
                if len(data) > 2:  # More than just type and timestamp
                    print(f"Parsed legacy format: {data}")
                    return data
            
            return None
            
        except Exception as e:
            print(f"Error parsing ESP32 data: {line} - {e}")
            return None


# Global bridge instance
bridge = None

async def handle_websocket(websocket, path):
    """WebSocket handler function"""
    global bridge
    
    client_address = websocket.remote_address
    print(f"[WebSocket] Connection attempt from {client_address}")
    
    await bridge.register_client(websocket)
    
    try:
        print(f"[WebSocket] Client {client_address} - Starting message loop")
        async for message in websocket:
            print(f"[WebSocket] Received message from {client_address}: {message[:100]}...")  # First 100 chars
            response = await bridge.handle_client_message(message)
            if response:
                await websocket.send(json.dumps(response))
                
    except websockets.exceptions.ConnectionClosed as e:
        print(f"[WebSocket] Connection closed from {client_address}: {e}")
    except Exception as e:
        print(f"[WebSocket] Error with client {client_address}: {e}")
        import traceback
        traceback.print_exc()
    finally:
        print(f"[WebSocket] Cleaning up connection from {client_address}")
        await bridge.unregister_client(websocket)


async def main():
    global bridge
    bridge = RobotBridge()
    
    # Start WebSocket server
    server = await websockets.serve(
        handle_websocket,
        "0.0.0.0",  # Listen on all interfaces
        WEBSOCKET_PORT
    )
    
    print(f"\n{'='*50}")
    print(f"WebSocket Bridge Server Running")
    print(f"{'='*50}")
    print(f"WebSocket: ws://0.0.0.0:{WEBSOCKET_PORT}")
    print(f"Mode: {COMM_MODE.upper()}")
    if COMM_MODE == 'serial':
        print(f"Serial: {SERIAL_PORT} @ {SERIAL_BAUD} baud")
    else:
        print(f"UDP: {ESP32_UDP_IP}:{ESP32_UDP_PORT}")
    print(f"{'='*50}")
    print(f"\nExpected ESP32 formats:")
    print(f"  Simple test:  ANALOG:1234")
    print(f"  Force sensors: FORCE:12.5,34.6,56.7,78.9,90.1")
    print(f"  Legacy format: THUMB:12.5,INDEX:34.6,...")
    print(f"{'='*50}\n")
    
    # Start ESP32 reader task
    esp32_task = asyncio.create_task(bridge.read_from_esp32())
    
    # Keep server running
    await asyncio.gather(server.wait_closed(), esp32_task)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nShutting down...")
