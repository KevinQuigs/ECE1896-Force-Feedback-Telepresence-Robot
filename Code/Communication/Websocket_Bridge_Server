"""
WebSocket Bridge Server for Telepresence Robot
Bridges between browser (WebSocket) and ESP32 (Serial)
"""

import asyncio
import websockets
import json
import serial
import struct
from datetime import datetime

# Configuration
WEBSOCKET_PORT = 8080
SERIAL_PORT = '/dev/ttyUSB0'  # Change to your ESP32 port (might be /dev/ttyACM0)
SERIAL_BAUD = 115200

# Communication mode: 'serial' or 'udp'
COMM_MODE = 'serial'
ESP32_UDP_IP = '192.168.1.50'  # If using UDP
ESP32_UDP_PORT = 5000

class RobotBridge:
    def __init__(self):
        self.clients = set()
        self.serial_conn = None
        self.udp_socket = None
        
        if COMM_MODE == 'serial':
            self.setup_serial()
        elif COMM_MODE == 'udp':
            self.setup_udp()
    
    def setup_serial(self):
        """Initialize serial connection to ESP32"""
        try:
            self.serial_conn = serial.Serial(
                SERIAL_PORT, 
                SERIAL_BAUD, 
                timeout=0.01
            )
            print(f"Serial connected: {SERIAL_PORT} @ {SERIAL_BAUD} baud")
        except Exception as e:
            print(f"Serial connection failed: {e}")
            print("  Check: ls /dev/ttyUSB* or ls /dev/ttyACM*")
    
    def setup_udp(self):
        """Initialize UDP socket for ESP32"""
        import socket
        self.udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        print(f"✓ UDP configured: {ESP32_UDP_IP}:{ESP32_UDP_PORT}")
    
    async def register_client(self, websocket):
        """Register new WebSocket client"""
        self.clients.add(websocket)
        print(f"Client connected. Total clients: {len(self.clients)}")
    
    async def unregister_client(self, websocket):
        """Unregister WebSocket client"""
        self.clients.discard(websocket)
        print(f"Client disconnected. Total clients: {len(self.clients)}")
    
    async def handle_client_message(self, message):
        """
        Handle incoming message from browser (VR controller/headset and finger tracking data)
        Format: {type: 'tracking', position: {x, y, z}, rotation: {x, y, z, w}}
        """
        try:
            data = json.loads(message)
            msg_type = data.get('type', 'unknown')
            
            if msg_type == 'tracking':
                # Extract position and rotation
                pos = data.get('position', {})
                rot = data.get('rotation', {})
                
                # Pack data for ESP32 (binary format for efficiency)
                # Format: [message_type(1 byte)][pos_x(4)][pos_y(4)][pos_z(4)][rot_x(4)][rot_y(4)][rot_z(4)][rot_w(4)]
                packed = struct.pack(
                    '<Bfffffff',  # < = little-endian, B = unsigned char, f = float
                    0x01,  # Message type: tracking data
                    pos.get('x', 0.0),
                    pos.get('y', 0.0),
                    pos.get('z', 0.0),
                    rot.get('x', 0.0),
                    rot.get('y', 0.0),
                    rot.get('z', 0.0),
                    rot.get('w', 1.0)
                )
                
                await self.send_to_esp32(packed)
                
            elif msg_type == 'command':
                # Handle discrete commands (grip, release, etc.)
                command = data.get('command', '')
                await self.send_to_esp32(f"CMD:{command}\n".encode())
                
            elif msg_type == 'ping':
                # Health check
                return {'type': 'pong', 'timestamp': datetime.now().isoformat()}
                
        except json.JSONDecodeError:
            print(f"✗ Invalid JSON: {message}")
        except Exception as e:
            print(f"✗ Error handling message: {e}")
        
        return None
    
    async def send_to_esp32(self, data):
        """Send data to ESP32 via serial or UDP"""
        try:
            if COMM_MODE == 'serial' and self.serial_conn:
                self.serial_conn.write(data)
            elif COMM_MODE == 'udp' and self.udp_socket:
                self.udp_socket.sendto(data, (ESP32_UDP_IP, ESP32_UDP_PORT))
        except Exception as e:
            print(f"✗ Error sending to ESP32: {e}")
    
    async def read_from_esp32(self):
        """Read sensor data from ESP32 and broadcast to all clients"""
        while True:
            try:
                if COMM_MODE == 'serial' and self.serial_conn and self.serial_conn.in_waiting > 0:
                    # Read line from ESP32
                    line = self.serial_conn.readline().decode('utf-8').strip()
                    
                    if line:
                        # Parse sensor data from ESP32
                        # Expected format: "FORCE:12.5,TEMP:25.3"
                        sensor_data = self.parse_esp32_data(line)
                        
                        if sensor_data and self.clients:
                            # Broadcast to all connected clients
                            message = json.dumps(sensor_data)
                            await asyncio.gather(
                                *[client.send(message) for client in self.clients],
                                return_exceptions=True
                            )
                
                await asyncio.sleep(0.01)  # 100Hz polling rate
                
            except Exception as e:
                print(f"✗ Error reading from ESP32: {e}")
                await asyncio.sleep(0.1)
    
    def parse_esp32_data(self, line):
        """Parse sensor data from ESP32"""
        try:
            # Example format: "FORCE:12.5,TEMP:25.3,POS:1.2,3.4,5.6"
            data = {'type': 'sensor', 'timestamp': datetime.now().isoformat()}
            
            parts = line.split(',')
            for part in parts:
                if ':' in part:
                    key, value = part.split(':', 1)
                    
                    if key == 'FORCE':
                        data['force'] = float(value)
                    elif key == 'TEMP':
                        data['temperature'] = float(value)
                    elif key == 'POS':
                        coords = value.split(',')
                        if len(coords) == 3:
                            data['position'] = {
                                'x': float(coords[0]),
                                'y': float(coords[1]),
                                'z': float(coords[2])
                            }
            
            return data if len(data) > 2 else None  # Must have more than just type and timestamp
            
        except Exception as e:
            print(f"✗ Error parsing ESP32 data: {line} - {e}")
            return None
    
    async def handle_websocket(self, websocket, path):
        """Handle WebSocket connection"""
        await self.register_client(websocket)
        
        try:
            async for message in websocket:
                response = await self.handle_client_message(message)
                if response:
                    await websocket.send(json.dumps(response))
                    
        except websockets.exceptions.ConnectionClosed:
            pass
        finally:
            await self.unregister_client(websocket)

async def main():
    bridge = RobotBridge()
    
    # Start WebSocket server
    server = await websockets.serve(
        bridge.handle_websocket,
        "0.0.0.0",  # Listen on all interfaces
        WEBSOCKET_PORT
    )
    
    print(f"\n{'='*50}")
    print(f"WebSocket Bridge Server Running")
    print(f"{'='*50}")
    print(f"WebSocket: ws://0.0.0.0:{WEBSOCKET_PORT}")
    print(f"Mode: {COMM_MODE.upper()}")
    if COMM_MODE == 'serial':
        print(f"Serial: {SERIAL_PORT} @ {SERIAL_BAUD} baud")
    else:
        print(f"UDP: {ESP32_UDP_IP}:{ESP32_UDP_PORT}")
    print(f"{'='*50}\n")
    
    # Start ESP32 reader task
    esp32_task = asyncio.create_task(bridge.read_from_esp32())
    
    # Keep server running
    await asyncio.gather(server.wait_closed(), esp32_task)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nShutting down...")
